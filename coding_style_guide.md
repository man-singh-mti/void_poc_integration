# Embedded C Coding Style Guide

## Overview

This style guide defines coding standards for embedded C99 development using the ARMCC5 compiler. It aligns with BARR-C guidelines and emphasizes readability, maintainability, and safety for embedded systems development. All team members must adhere to these guidelines to ensure code quality and consistency across the project.

## Table of Contents

1. [Code Architecture](#code-architecture)
2. [File Organization](#file-organization)
3. [Naming Conventions](#naming-conventions)
4. [Formatting](#formatting)
5. [Comments and Documentation](#comments-and-documentation)
6. [Variables and Types](#variables-and-types)
7. [Functions](#functions)
8. [Control Structures](#control-structures)
9. [Preprocessor Usage](#preprocessor-usage)
10. [Memory Management](#memory-management)
11. [Error Handling](#error-handling)
12. [Hardware Interfaces](#hardware-interfaces)
13. [Interrupt Handling](#interrupt-handling)
14. [Build Configuration](#build-configuration)
15. [Best Practices](#best-practices)
16. [References](#references)
17. [Version History](#version-history)
18. [Documentation Badges](#documentation-badges)

---

## Code Architecture

### Layered Architecture

The codebase follows a layered architecture with clear separation of concerns:

```ascii
                  ┌───────────────────────┐
                  │   Application Layer   │
                  └─────────┬─────────────┘
                            │
                  ┌─────────▼─────────────┐
                  │   Middleware/         │
                  │   Driver Layer        │
                  └─────────┬─────────────┘
                            │
                  ┌─────────▼─────────────┐
                  │      Core/HAL         │
                  └─────────┬─────────────┘
                            │
                  ┌─────────▼─────────────┐
                  │      Hardware         │
                  └───────────────────────┘
```

Each layer should have well-defined interfaces and strict dependency rules:

- Higher layers may depend on lower layers, but not vice versa
- Dependencies should be explicitly documented in header files
- Circular dependencies must be avoided

### Directory Structure and Naming

The project follows a standardized directory structure:

```ASCII
Project/
├── Core/                 # STM32CubeMX generated core files
│   ├── Inc/              # Core header files
│   └── Src/              # Core source files
├── Device/               # Engineering team custom device layer
│   ├── Inc/              # Device layer header files
│   └── Src/              # Device layer source files
├── Drivers/              # Standard peripheral drivers
│   ├── CMSIS/            # CMSIS files
│   └── STM32Fxxx_HAL/    # HAL driver files
├── MDK-ARM/              # Keil IDE project files
├── Config/               # Configuration files
├── Docs/                 # Documentation
└── Scripts/              # Build and utility scripts
```

### Module Types and Naming

Files should be organized by module type, each with a specific prefix:

- **Application Modules** (`app_*`): High-level application logic
  - Example: `app_sensor_fusion.c`, `app_data_logger.c`
  - Located in: `Device/Src/` and `Device/Inc/`

- **Driver/Middleware Modules** (`drv_*`): Middleware abstractions that bridge between application and hardware
  - Example: `drv_imu.c`, `drv_temperature.c`, `drv_flash.c`
  - Located in: `Device/Src/` and `Device/Inc/`
  - These provide hardware-independent APIs to the application layer
  - Implement protocols, state machines, and business logic related to specific subsystems
  - May manage multiple lower-level peripherals to provide a unified interface

- **Utility Modules** (`util_*`): Common functionality and helper functions
  - Example: `util_buffer.c`, `util_math.c`, `util_crc.c`
  - Located in: `Device/Src/` and `Device/Inc/`

- **Core Modules**: Low-level MCU peripherals (typically generated by STM32CubeMX)
  - Example: `gpio.c`, `adc.c`, `spi.c`
  - Located in: `Core/Src/` and `Core/Inc/`
  - Provide direct hardware access

**Rationale:** This directory structure clearly separates different layers of the software:

1. Application code that implements system functionality
2. Driver/middleware code that abstracts hardware details but provides domain-specific interfaces
3. Core/HAL code that directly interfaces with the hardware

### Dependency Flow

```ascii
app_* -> drv_* -> Core/HAL
   |
   -> util_* -> Core/HAL
```

- **Application modules** (`app_*`) may use other application modules, drivers, and utilities
- **Driver modules** (`drv_*`) may use other drivers, utilities, and Core/HAL functions
- **Utility modules** (`util_*`) may use other utility modules, drivers, and Core/HAL
- **Core/HAL modules** have no dependencies on other modules

---

## File Organization

### Header Files

```c
/*******************************************************************************
 * @file    module_name.h
 * @brief   Short description of the module functionality
 * @author  Author Name
 * @date    YYYY-MM-DD
 *
 * @details More detailed description of the module's purpose
 *****************************************************************************/

#ifndef MODULE_NAME_H
#define MODULE_NAME_H

/* Includes */

/* Macros and Constants */

/* Data Types */

/* Function Prototypes */

#endif /* MODULE_NAME_H */
```

### Source Files

```c
/*******************************************************************************
 * @file    module_name.c
 * @brief   Implementation of module_name
 * @date    YYYY-MM-DD
 *****************************************************************************/

/* Includes */

/* Private Constants */

/* Private Types */

/* Private Variables */

/* Private Function Prototypes */

/* Private Function Implementations */

/* Public Function Implementations */
```

**Rationale:** Consistent file organization creates a predictable codebase structure that improves readability and helps new developers quickly understand the project architecture.

---

## Naming Conventions

### General Rules

- Use descriptive names that clearly convey purpose
- Make names as concise as practical without sacrificing clarity
- Use consistent prefixes and suffixes to indicate scope and type

### Specific Naming Patterns

| Type              | Convention             | Example                       |
|-------------------|------------------------|-------------------------------|
| Variables         | snake_case             | `current_sensor_value`        |
| Constants         | UPPER_SNAKE_CASE       | `MAX_BUFFER_SIZE`             |
| Macros            | UPPER_SNAKE_CASE       | `CALCULATE_CHECKSUM(x)`       |
| Functions         | snake_case, verb-based | `initialize_device()`         |
| Types             | snake_case_t           | `sensor_config_t`             |
| Files             | snake_case.ext         | `temperature_sensor.c`        |
| Enum Tags         | snake_case_e           | `typedef enum operation_mode_e {...}`  |
| Enum Types        | snake_case_t           | `operation_mode_t`            |
| Enum Members      | UPPER_SNAKE_CASE       | `MODE_STANDBY`                |
| Global Variables  | g_snake_case           | `g_system_state`              |
| Private Functions | static snake_case      | `static calculate_checksum()` |
| Unions            | snake_case_u           | `data_converter_u`            |

**Rationale:** Consistent naming conventions improve readability and convey additional information about variable scope, purpose, and type.

---

## Formatting

### Indentation and Spacing

- Use 4 spaces for indentation (not tabs)
- Limit line length to 160 characters
- Align related variable declarations and assignments
- Place spaces after keywords and around operators
- No space between function name and opening parenthesis
- One space after commas in parameter lists

### Braces

- Opening brace on a new line for functions and control structures
- Closing brace aligned with the start of the opening line
- Always use braces for control structures, even for single-line blocks

```c
if (condition)
{
    single_statement();
}

void function_name(int parameter)
{
    /* Function body */
}
```

### Parentheses and Operators

- Use parentheses liberally to clarify operator precedence
- Always surround conditional expressions with parentheses
- Binary operators should have spaces on both sides

```c
if ((a > b) && (c < d))
{
    result = (a + b) * (c / d);
}
```

**Rationale:** Consistent formatting makes the code easier to read and understand, while proper use of parentheses prevents precedence bugs.

---

## Comments and Documentation

### File Headers

All files must have a header comment including:

- File name
- Brief description
- Author name
- Creation date
- Detailed description (if appropriate)

### Function Documentation

```c
/**
 * @brief  Short description of function purpose
 * @param[in]  input_param  Description of input parameter
 * @param[out] output_param Description of output parameter
 * @param[in,out] io_param  Description of parameter used for input and output
 * @return Description of return value
 * @note   Any relevant notes about usage or limitations
 */
```

### Code Comments

- Use comments to explain "why" not "what"
- Comments should add information not obvious from the code
- Keep comments up to date with the code
- Use standardized section dividers:

```c
//=============================================================================
// Section Name
//=============================================================================
```

### Dependency Documentation

Document module dependencies in header files:

```c
/*******************************************************************************
 * @file    app_sensor_fusion.h
 * @brief   Sensor fusion algorithms for orientation tracking
 * 
 * @dependencies  drv_imu.h, util_math.h, util_buffer.h
 *****************************************************************************/
```

**Rationale:** Good comments explain the intent and reasoning behind the code, making it easier to understand, maintain, and extend.

---

## Variables and Types

### Declaration and Initialization

- Declare variables at the smallest possible scope
- Initialize variables at declaration when possible
- Use const qualifier aggressively
- Use fixed-width integer types from stdint.h
- Align variable declarations for readability

```c
static const uint32_t MAX_RETRIES  = 3U;   /**< Maximum initialization retries */
static const uint16_t TIMEOUT_MS   = 100U; /**< Delay between retries [ms] */
static       uint8_t  retry_count  = 0U;   /**< Current retry counter */
```

### Global Variables

- Minimize use of global variables
- Prefix global variables with `g_`
- Document purpose and usage in header file
- Consider declaring frequently accessed globals as volatile if they can be modified by ISRs

### Type Definitions

- Use typedefs for clarity and to abstract implementation details
- Add suffixes to types based on their category:
  - `_t` for general types
  - `_e` for enums
  - `_u` for unions
  - `_cb` for callback function types

```c
/**
 * @brief Configuration parameters for sensor initialization
 */
typedef struct
{
    uint16_t sample_rate_hz;  /**< Sampling frequency in Hz */
    uint8_t  resolution_bits; /**< ADC resolution in bits */
    bool     auto_calibrate;  /**< Enable auto-calibration */
} sensor_config_t;
```

### Enumerations

- Use enums to define related constants
- Document the purpose of each enumeration value
- Use a common prefix for all values in an enum
- Use named enum tags with \_e suffix and typedef with \_t suffix for clarity

```c
/**
 * @brief System operating modes
 */
typedef enum system_mode_e
{
    MODE_STANDBY,  /**< Low-power standby */
    MODE_NORMAL,   /**< Normal operation */
    MODE_CALIBRATE /**< Sensor calibration */
} system_mode_t;
```

### Unions

- Use unions only when memory optimization is critical or for register access
- Add _u suffix to union type names
- Document the purpose and proper usage of each union
- Consider tagged unions for type safety

```c
/**
 * @brief Data conversion union for efficient memory access
 * @note  Only one member should be accessed after a write
 */
typedef union
{
    uint32_t u32;           /**< Access as a 32-bit value */
    uint16_t u16[2];        /**< Access as two 16-bit values */
    uint8_t  u8[4];         /**< Access as four 8-bit values */
} data_converter_u;

/**
 * @brief Tagged union for type-safe storage of different data types
 */
typedef struct
{
    enum value_type_e { INTEGER, FLOAT } type; /**< Indicates which union member is valid */
    
    union
    {
        int32_t i_value;     /**< Integer value storage */
        float   f_value;     /**< Float value storage */
    } data;                  /**< The data storage union */
} sensor_value_t;
```

### Bit-field Unions and Hardware Registers

- For every bit-field union, state target endianness and alignment in its header
- If endianness cannot be fixed, replace the union with explicit #define MASK and shift operations
- Document register address, access permissions, and reset values

```c
/**
 * @brief Control register bit access
 * @note  Maps to hardware register at 0x4000A000
 *        Target Architecture: Little-endian, 32-bit aligned
 *        See hardware reference manual v2.3, section 4.2
 */
typedef union
{
    uint32_t raw;        /**< Raw 32-bit access */
    
    struct
    {
        uint32_t enable     : 1;  /**< Module enable bit */
        uint32_t mode       : 2;  /**< Operating mode: 00=off, 01=normal, 10=test */
        uint32_t interrupt  : 1;  /**< Interrupt enable */
        uint32_t reserved1  : 4;  /**< Reserved bits */
        uint32_t prescaler  : 8;  /**< Clock prescaler value */
        uint32_t reserved2  : 16; /**< Reserved bits */
    } bits;              /**< Bit field access */
} control_register_u;

/**
 * @brief Non-union approach for portable code (endianness-agnostic)
 */
#define CTRL_ENABLE_POS      (0U)
#define CTRL_ENABLE_MASK     (1U << CTRL_ENABLE_POS)
#define CTRL_MODE_POS        (1U)
#define CTRL_MODE_MASK       (3U << CTRL_MODE_POS)
#define CTRL_INTERRUPT_POS   (3U)
#define CTRL_INTERRUPT_MASK  (1U << CTRL_INTERRUPT_POS)
#define CTRL_PRESCALER_POS   (8U)
#define CTRL_PRESCALER_MASK  (0xFFU << CTRL_PRESCALER_POS)
```

**Rationale:** Proper variable declarations and type definitions improve type safety and self-documentation, while minimizing the risk of undefined behavior.

---

## Functions

### Function Design

- Functions should perform a single, well-defined task
- Keep functions short (< 50 lines when possible)
- Limit function parameters (4 or fewer when possible)
- Return error codes for error handling

### Function Prototypes

```c
/**
 * @brief  Function documentation as described in Comments section
 */
int32_t module_action_verb(uint8_t param1, float param2);
```

### Function Definitions

```c
int32_t module_action_verb(uint8_t param1, float param2)
{
    /* Function implementation */
    return SUCCESS_CODE;
}
```

### Function Scope

- Mark functions not used outside the module as `static`
- Document all public functions in the header file
- Only expose functions that are part of the module's interface

**Rationale:** Well-designed functions with a single responsibility are easier to test, maintain, and reuse. Clear separation of public and private functions improves module encapsulation.

---

## Control Structures

### Conditionals

- Always use braces, even for single-statement blocks
- Keep nesting level low (3 levels or fewer when possible)
- Use early returns to reduce nesting

```c
if (error_condition)
{
    /* Handle error */
    return ERROR_CODE;
}
/* Continue with normal execution */
```

### Loops

- Prefer for loops when the number of iterations is known
- Use while loops for condition-based termination
- Use do-while loops judiciously (only when the loop body must execute at least once)
- Always use braces for loop bodies

```c
for (uint8_t i = 0U; i < MAX_ITERATIONS; i++)
{
    /* Loop body */
}

while (condition)
{
    /* Loop body */
}

do
{
    /* Loop body that must execute at least once */
} while (condition);
```

### Switch Statements

- Always include a default case
- End each case with a break or explicit fallthrough comment
- Align case statements with the switch statement

```c
switch (value)
{
    case CASE_A:
        /* Handle case A */
        break;
    case CASE_B:
        /* Handle case B */
        /* Intentional fallthrough */
    case CASE_C:
        /* Handle cases B and C */
        break;
    default:
        /* Handle unexpected values */
        break;
}
```

**Rationale:** Consistent control flow practices reduce the likelihood of logical errors and improve code readability.

---

## Preprocessor Usage

### Include Guards

- Use #ifndef guards for all header files
- Name the guard after the file name (uppercase with underscores)
- Set each include guard to the uppercase filename with underscores (#ifndef APP_SENSOR_FUSION_H for app_sensor_fusion.h)

```c
#ifndef MODULE_NAME_H
#define MODULE_NAME_H
/* Header content */
#endif /* MODULE_NAME_H */
```

### Include Statements

- Include system headers first, then project headers
- Use angle brackets for system includes, quotes for project includes
- Group includes logically and alphabetically within groups

```c
#include <stdint.h>
#include <stdlib.h>

#include "module_a.h"
#include "module_b.h"
```

### Macros

- Use macros sparingly, prefer inline functions when possible
- Always surround macro parameters with parentheses
- Use UPPER_SNAKE_CASE for macro names
- Allow macros only for single statements or expressions
- Convert any multi-statement macro into a static inline function with proper type signatures

```c
// AVOID: Multi-statement macro
#define SAFE_FREE(ptr) \
    do { \
        if ((ptr) != NULL) \
        { \
            free(ptr); \
            (ptr) = NULL; \
        } \
    } while (0)

// PREFER: Static inline function
static inline void safe_free(void** ptr)
{
    if (*ptr != NULL)
    {
        free(*ptr);
        *ptr = NULL;
    }
}
```

**Rationale:** Careful use of preprocessor directives prevents common inclusion and compilation issues while making the code more maintainable.

---

## Memory Management

### Dynamic Allocation

- Prohibit use of malloc/free in production code
- Implement a static-pool allocator: preallocate fixed-size memory pools, manage allocation/free via indices or bitmaps
- Allocate all memory during initialization phase
- Document memory pool sizes and allocation strategies
- Have a clear ownership strategy for memory resources

### Buffer Safety

- Always validate buffer sizes before operations
- Use sizeof operator with the actual buffer, not the type
- Check for potential overflow before performing operations

```c
if (data_size <= sizeof(buffer))
{
    memcpy(buffer, data, data_size);
}
else
{
    /* Handle buffer overflow condition */
}
```

**Rationale:** Safe memory management is crucial for embedded systems to prevent crashes, data corruption, and security vulnerabilities.

---

## Error Handling

### Error Codes

- Use standardized error codes throughout the project
- Return specific error codes from functions rather than generic failure indicators
- Document the meaning of each error code

```c
/* Common error codes */
#define SUCCESS          0    /**< Operation completed successfully */
#define ERR_INVALID_PARAM -1  /**< Invalid parameter provided */
#define ERR_TIMEOUT      -2   /**< Operation timed out */
#define ERR_RESOURCE     -3   /**< Resource unavailable */
```

### Error Checking

- Always check return values from functions that can fail
- Handle all error conditions explicitly
- Don't ignore errors by writing empty catch blocks

```c
result = initialize_device();
if (result != SUCCESS)
{
    /* Handle specific error condition */
    return result;
}
```

### Assertions

- Use assertions for conditions that should never happen in correct code
- Don't use assertions for expected runtime conditions
- Make sure assertions can be disabled in release builds

```c
assert(pointer != NULL); /* This should never be NULL in correct code */
```

**Rationale:** Comprehensive error handling improves system robustness and makes debugging easier by detecting and identifying issues early.

---

## Hardware Interfaces

### Register Access

- Use hardware abstraction functions when possible for portability
- When direct register access is needed for performance:
  - Create well-named macros or inline functions
  - Document the hardware behavior and any side effects

```c
/* Hardware abstraction approach */
gpio_write(GPIO_PORT_A, GPIO_PIN_5, GPIO_HIGH);

/* Direct register access when needed */
#define SET_LED()   (GPIOA->BSRR = GPIO_PIN_5)
#define CLEAR_LED() (GPIOA->BSRR = (GPIO_PIN_5 << 16))
```

### Register Bit Access

- For register bit manipulation, use named bit fields over shifting/masking
- Ensure bit field layout matches hardware register specification
- Document register mappings with references to hardware documentation

```c
/**
 * @brief Control register bit access
 * @note  Maps to hardware register at 0x4000A000
 *        Target Architecture: Little-endian, 32-bit aligned
 *        See hardware reference manual v2.3, section 4.2
 */
typedef union
{
    uint32_t raw;        /**< Raw 32-bit access */
    
    struct
    {
        uint32_t enable     : 1;    /**< Module enable bit */
        uint32_t mode       : 2;    /**< Operating mode: 00=off, 01=normal, 10=test */
        uint32_t interrupt  : 1;    /**< Interrupt enable */
        uint32_t reserved1  : 4;    /**< Reserved bits */
        uint32_t prescaler  : 8;    /**< Clock prescaler value */
        uint32_t reserved2  : 16;   /**< Reserved bits */
    } bits;                         /**< Bit field access */
} control_register_u;

/**
 * @brief Non-union approach for portable code (endianness-agnostic)
 */
#define CTRL_ENABLE_POS      (0U)
#define CTRL_ENABLE_MASK     (1U << CTRL_ENABLE_POS)
#define CTRL_MODE_POS        (1U)
#define CTRL_MODE_MASK       (3U << CTRL_MODE_POS)
#define CTRL_INTERRUPT_POS   (3U)
#define CTRL_INTERRUPT_MASK  (1U << CTRL_INTERRUPT_POS)
#define CTRL_PRESCALER_POS   (8U)
#define CTRL_PRESCALER_MASK  (0xFFU << CTRL_PRESCALER_POS)
```

**Rationale:** Hardware abstraction improves code portability and maintainability by isolating hardware-specific code and providing clear documentation of hardware interactions.

---

## Interrupt Handling

### Interrupt Service Routines

- Keep ISRs as short and fast as possible
- Use the appropriate compiler-specific attribute
- Don't use recursive functions, dynamic memory, or blocking operations in ISRs
- Prefix ISR function names with `ISR_` to clearly identify them
- Use volatile for variables shared between ISR and main code

```c
/**
 * @brief  UART receive interrupt handler
 * @note   Processes incoming UART data
 */
void ISR_UART_RX(void)
{
    /* Clear interrupt flag first */
    UART->SR &= ~UART_SR_RXNE;
    
    /* Process data quickly */
    volatile uint8_t data = UART->DR;
    
    /* Pass to main code via buffer */
    if (g_rx_buffer_count < RX_BUFFER_SIZE)
    {
        g_rx_buffer[g_rx_buffer_write_index] = data;
        g_rx_buffer_write_index = (g_rx_buffer_write_index + 1) % RX_BUFFER_SIZE;
        g_rx_buffer_count++;
    }
}
```

### Critical Sections

- Use critical sections sparingly and keep them as short as possible
- Always restore interrupt state when exiting a critical section
- Document the purpose of each critical section

```c
uint32_t prev_primask;
/* Enter critical section */
prev_primask = __get_PRIMASK();
__disable_irq();

/* Critical code here */
shared_resource += 1;

/* Exit critical section - restore previous interrupt state */
__set_PRIMASK(prev_primask);  /* Properly handles nested critical sections */
```

**Rationale:** Proper interrupt handling is crucial for reliable embedded systems. Following these guidelines helps prevent race conditions and timing issues.

---

## Build Configuration

### Compiler Options

- Use appropriate optimization levels for debug vs. release builds
- Enable relevant warnings and treat them as errors
- Define a common set of compiler flags across projects

### Project Structure

- Store all project settings in version control
- Document build configurations and their purposes
- Use consistent file paths relative to the project
- Configure static analysis tools to enforce coding standards

**Rationale:** Consistent build settings ensure reproducible builds and help catch potential issues early in the development process.

---

## Best Practices

1. **Be consistent:** Follow the style guide consistently throughout the project.

2. **Write for readability:** Code is read more often than it's written. Optimize for human understanding.

3. **Keep it simple:** Simple code is easier to understand and maintain. Avoid unnecessary complexity.

4. **Test thoroughly:** Verify all code paths work as expected. Write tests when appropriate.

5. **Document wisely:** Focus documentation on explaining "why" not "what." Keep it up-to-date.

6. **Review code:** Peer review helps maintain quality and catch issues early.

7. **Use static analysis:** Tools like clang-tidy help enforce style guidelines automatically.

8. **Optimize judiciously:** Write correct code first, then optimize only where necessary and with measurements.

9. **Manage technical debt:** Refactor problematic code when appropriate instead of accumulating technical debt.

10. **Plan for maintenance:** Write code with future maintenance in mind.

---

## References

- BARR-C Coding Standard
- Embedded C Coding Standard by Michael Barr
- C99 Language Standard

---

## Version History

| Version | Date       | Author | Description     |
|---------|------------|--------|-----------------|
| 1.0.0   | 2025-05-09 | Team   | Initial version |

## Documentation Badges

### Badge Usage Guidelines

Badges provide quick visual indicators of project status and important information. Follow these guidelines when using badges in project documentation:

### Badge Placement

- Place badges at the top of the README.md file, before any heading or text
- Left-align all badges on their own line
- Group badges by type (build status, version, license, etc.)
- Maintain a single line of badges when possible for cleaner appearance

### Badge Selection

- Use badges sparingly; avoid cluttering the README with too many badges
- Include only badges that provide valuable information to users and contributors
- Prioritize important badges first (build status > version > license)
- Each badge should serve a clear purpose and add value

### Badge Order

Follow this recommended order for badges:

1. Build/CI status
2. Version/Release
3. License
4. Documentation status
5. Code standards compliance
6. Other project-specific metrics

### Badge Maintenance

- Ensure all badges reflect current project status
- Remove or update obsolete badges promptly
- Link badges to relevant information sources when applicable
- Use consistent styling across all badges (color scheme, dimensions)

### Badge Implementation

Use markdown image syntax with appropriate links:

```markdown
![Badge Name](https://img.shields.io/badge/Label-Value-color.svg)
```

Example badges:

- Build status: `![Build](https://img.shields.io/badge/Build-Passing-brightgreen.svg)`
- Version: `![Version](https://img.shields.io/badge/Version-1.0.0-blue.svg)`
- License: `![License](https://img.shields.io/badge/License-Proprietary-red.svg)`

For dynamic badges connected to CI/CD systems, use the appropriate shield.io endpoints or service-specific badge URLs.

**Rationale:** Consistent badge usage improves documentation readability and provides stakeholders with important project information at a glance, while maintaining a professional and organized appearance.
